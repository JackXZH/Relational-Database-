SET search_path TO amused_herd;

-- Add a table called `departments` in the amused_herd schema .  It should have at least three columns: `id`, `name`, and `abbreviation`.

DROP TABLE IF EXISTS departments CASCADE;
CREATE TABLE departments (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE CHECK (char_length(name) > 0 AND char_length(name) < 100),
    abbreviation TEXT NOT NULL UNIQUE CHECK (UPPER(abbreviation) = abbreviation AND abbreviation ~ '^[A-Z]{3,4}$')
);

-- * Add the following departments to the database
--   (I should mention 
--   at this point that my tests are run only at the end of your code so you can 
--   do data entry like this at the end, after creating your schema, if you want
--   to do so. It doesn't matter.)
--   * `Management`, `MGT`
--   * `Computer Science`, `CPSC`
--   * `Drama`, `DRAM`

INSERT INTO departments (name, abbreviation) 
VALUES 
    ('Management', 'MGT'),
    ('Computer Science', 'CPSC'),
    ('Drama', 'DRAM');

-- * Add a table called `roles` with at least two columns: `id` and `name`.
--   * `id` should be an `IDENTITY` primary key
--     generated by default always.
--   * `name` should be text. It may not be null and
--     it must be unique. It should be lowercase and be more than zero but fewer than 25 characters.

DROP TABLE IF EXISTS roles CASCADE;
CREATE TABLE roles (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE CHECK (LOWER(name) = name AND char_length(name) > 0 AND char_length(name) < 25)
);

-- * Create a role with name "faculty" and role with name "student"
INSERT INTO roles(name) 
VALUES
    ('faculty'),
    ('student');

-- * Add a `users` table.  The table should have the following columns
--   * `name`, a text field that may not be null and must have a length of
--     more than 0 characters and fewer than 100.
--   * `netid`, a text primary key. Must have a length greater than 2 and fewer than 10 characters
--     and must be all lower case letters and numbers. It must begin with a letter.
--     The regex I used in my solutions is `'^[a-z][a-z0-9]{2,9}$')`.
--   * `email`, a text field that may not be null, must be a valid email address,
--     and must be unique. It should be more than zero but fewer than 100 characters.
--     Here is what [my email column in the solutions](https://gist.github.com/kljensen/8a140ab947ed09db0563a62f55f53a22) looks like.
--   * `updated_at` of type `timestamp with time zone` (that's `timestamptz`) which may not be null and defaults to `NOW()`.
--   * `role_id`, a foreign key to the `id` column in the `roles` table that
--     may not be null. (Unless I say otherwise, you don't need to add any condition
--     to handle [cascading deletes or updates](https://kb.objectrocket.com/postgresql/how-to-use-the-postgresql-delete-cascade-1369)
--     on foreign keys.
--     There are _no tests of cascading deletes or updates_ in the grading code.)

CREATE TABLE users (
    name TEXT NOT NULL CHECK (char_length(name) > 0 AND char_length(name) < 100),
    netid TEXT PRIMARY KEY CHECK (netid ~ '^[a-z][a-z0-9]{2,9}$'),
    email TEXT NOT NULL UNIQUE CHECK (
    email ~ '@.*\.'
    AND
    email ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0    -9-]{0,61}[a-zA-Z0-9])?)*$'
    AND
    char_length(email) < 100),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    role_id INT NOT NULL,
    FOREIGN KEY (role_id) REFERENCES roles(id)
);


-- * Create a [trigger](https://www.postgresqltutorial.com/postgresql-triggers/) that will 
--   set the `updated_at` column of a row in users to `now()` whenever the row is updated.
--   As with table creation, make sure this is idempotent. Use `CREATE OR REPLACE FUNCTION` and
--   `DROP TRIGGER IF EXISTS` (Google it ðŸ˜Ž) accomplish that, otherwise you're going to 
--   get errors when you rerun your `answer.sql` SQL. This is a [common pattern](https://x-team.com/blog/automatic-timestamps-with-postgresql/).


DROP TRIGGER IF EXISTS update_updated_at_trigger ON users;
-- Create or replace the function to ensure idempotency
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- Create the trigger, using the function
CREATE TRIGGER update_updated_at_trigger
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();


-- * Please add the following students to the user table. (Please try to do this "properly",
--   by not hard-coding the `role_id`, you might think about using 
--   the so-called "insert into select" form 
--   to accomplish the `INSERT`. But, I'm not going to check how you do it ðŸ˜‰.)
--   * Kwame Abara, `ka234`, `kwame.abara@yale.edu`
--   * Hua Zhi Ruo, `hzr98`, `zhirho.hua@yale.edu`
--   * Magnus Hansen, `mh99`, `magnus.hansen@yale.edu`
--   * Saanvi Ahuja, `ska299`, `saanvi.ahuja@yale.edu`
--   * Isabella Torres, `ift12`, `isabella.torres@yale.edu`
-- * Please add the following faculty to the user table
--   * Kyle Jensen, `klj39`, `kyle.jensen@yale.edu`
--   * Judy Chevalier, `jc288`, `judith.chevalier@yale.edu`
--   * Huang Zeqiong, `zh44`, `zeqiong.huang@yale.edu`


INSERT INTO users (name, netid, email, role_id)
VALUES
    ('Kwame Abara', 'ka234', 'kwame.abara@yale.edu', (SELECT id FROM roles WHERE name = 'student')),
    ('Hua Zhi Ruo', 'hzr98', 'zhirho.hua@yale.edu', (SELECT id FROM roles WHERE name = 'student')),
    ('Magnus Hansen', 'mh99', 'magnus.hansen@yale.edu', (SELECT id FROM roles WHERE name = 'student')),
    ('Saanvi Ahuja', 'ska299', 'saanvi.ahuja@yale.edu', (SELECT id FROM roles WHERE name = 'student')),
    ('Isabella Torres', 'ift12', 'isabella.torres@yale.edu', (SELECT id FROM roles WHERE name = 'student')),
    ('Kyle Jensen', 'klj39', 'kyle.jensen@yale.edu', (SELECT id FROM roles WHERE name = 'faculty')),
    ('Judy Chevalier', 'jc288', 'judith.chevalier@yale.edu', (SELECT id FROM roles WHERE name = 'faculty')),
    ('Huang Zeqiong', 'zh44', 'zeqiong.huang@yale.edu', (SELECT id FROM roles WHERE name = 'faculty'));




-- * Add a `terms` table. The table should have three columns.
--   * `id` should be an `IDENTITY` primary key
--     generated by default always.
--   * `label` should be of type `TEXT` and not null, more than three
--     and fewer than 20 characters in length.
--   * `dates` of type `DATERANGE` that may not be null. (Checkout the [daterange](https://www.postgresql.org/docs/9.3/rangetypes.html) 
--     rangetype documentation)
--   * The table should have a so-called ["exclusion constraint"](https://www.postgresql.org/docs/9.1/sql-createtable.html)
--     such that no two terms have `dates` that overlap. (I should remind you
--     at this point that this is just an example database. Obviously, we have
--     terms at Yale that do overlap, like Spring and Spring II! 
--     A better example use of a exclusion constraint would be something like
--     an AirBnb rental. Or, I could have asked you to design a table that
--     holds student schedules and you could have used an exclusion constraint
--     to prohibit students from being in two classes that meet at the same
--     time. You could even say something like "student classes need to be
--     15 minutes apart". All that said, I thought this example was enough
--     to familiarize you with the concept.)

DROP TABLE IF EXISTS terms CASCADE;
CREATE TABLE terms (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    label TEXT NOT NULL CHECK (char_length(label) > 3 AND char_length(label) < 20),
    dates DATERANGE NOT NULL,
    EXCLUDE USING gist (dates WITH &&)
);


-- * Add the following `terms` to the database. It does not matter if the last
--   date is included or not (you know...open set, closed set...it doesn't matter
--   because I won't test on the margins of your ranges).
--   * "Spring 2021", 2021-01-19 - 2021-05-13
--   * "Fall 2021", 2021-08-01 - 2021-12-13

INSERT INTO terms (label, dates)
VALUES
    ('Spring 2021', daterange('2021-01-19', '2021-05-13')),
    ('Fall 2021', daterange('2021-08-01', '2021-12-13'));


-- * Create a `courses` table with the following columns
--   * `id` should be an `IDENTITY` primary key
--     generated by default always.
--   * `department_id` a foreign key to `departments(id)`, not null.
--   * `number` an INT, not null, greater than 99 and less than 1000.
--   * `name` TEXT greater than 5 characters and fewer than 100, not null
--   * `faculty_netid` a foreign key to a `users(netid)` not null.
--   * `term_id` a foreign key to a `terms(id)` not null

DROP TABLE IF EXISTS courses CASCADE;
CREATE TABLE courses (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    department_id INT NOT NULL,
    number INT NOT NULL CHECK (number > 99 AND number < 1000),
    name TEXT NOT NULL CHECK (char_length(name) > 5 AND char_length(name) < 100),
    faculty_netid TEXT NOT NULL,
    term_id INT NOT NULL,
    FOREIGN KEY (department_id) REFERENCES departments(id),
    FOREIGN KEY (faculty_netid) REFERENCES users(netid),
    FOREIGN KEY (term_id) REFERENCES terms(id),
    UNIQUE (term_id, department_id, number)
);


-- * Add the following courses, again, please don't assume that you know
--   numeric primary keys ðŸ¤“. That is, when do you do the insert, you shouldn't
--   assume you know the primary key for the "Spring 2021" term is "5" or whatever.
--   * "Apps, Programming, and Entrepreneurship", "CPSC-213" taught in "Spring 2021" by "klj39"  (Kyle)
--   * "Strategic Management of Nonprofit Organizations", "MGT-527" taught in "Fall 2021" by  "jc288" (Judy)

INSERT INTO courses (department_id, number, name, faculty_netid, term_id)
VALUES
    ((SELECT id FROM departments WHERE abbreviation = 'CPSC'), 213, 'Apps, Programming, and Entrepreneurship', 'klj39', (SELECT id FROM terms WHERE label = 'Spring 2021')),
    ((SELECT id FROM departments WHERE abbreviation = 'MGT'), 527, 'Strategic Management of Nonprofit Organizations', 'jc288', (SELECT id FROM terms WHERE label = 'Fall 2021'));


CREATE TABLE enrollments (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    course_id INT NOT NULL,
    student_netid TEXT NOT NULL,
    grade TEXT CHECK (grade ~ '[ABCDF][+-]?' AND grade !~ '(A\+|F\+|F\-)'),
    FOREIGN KEY (course_id) REFERENCES courses(id),
    FOREIGN KEY (student_netid) REFERENCES users(netid),
    UNIQUE (course_id, student_netid)
);

INSERT INTO enrollments (course_id, student_netid, grade)
VALUES
    ((SELECT id FROM courses WHERE faculty_netid = 'klj39'), 'ka234', 'A'),
    ((SELECT id FROM courses WHERE faculty_netid = 'klj39'), 'hzr98', 'A'),
    ((SELECT id FROM courses WHERE faculty_netid = 'jc288'), 'hzr98', 'A'),
    ((SELECT id FROM courses WHERE faculty_netid = 'jc288'), 'mh99', 'A');


CREATE VIEW roster AS
SELECT
    terms.label AS term,
    departments.name AS department,
    courses.number AS course_number,
    users.name AS name,
    users.email AS email
FROM 
    terms
JoIN courses ON terms.id = courses.term_id
JOIN departments ON courses.department_id = departments.id
JOIN enrollments ON enrollments.course_id = courses.id
JOIN users ON enrollments.student_netid = users.netid;



SELECT * FROM roster;


